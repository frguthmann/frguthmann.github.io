<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Welcome to The GutHub! on The GutHub</title>
    <link>/</link>
    <description>Recent content in Welcome to The GutHub! on The GutHub</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 13 Aug 2019 18:00:00 +0200</lastBuildDate>
    
	<atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Shimming d3d12.dll for fun and profit</title>
      <link>/posts/shimming_d3d12/</link>
      <pubDate>Sun, 09 Jun 2024 12:55:28 +0200</pubDate>
      
      <guid>/posts/shimming_d3d12/</guid>
      <description>Why would anyone do this? I have been playing around with WebGPU recently, writing a toy engine in JS and running it on Chrome. The debugging situation is great now, PIX just works and I can usually identify and fix issues quickly when they arise. However, when it comes to profiling, well the situation is not that great. For instance, AMD&amp;rsquo;s Radeon Developer Panel will detect Chrome as a DX12 app (when using the proper flags), it will attach to the process and even let me start a capture.</description>
    </item>
    
    <item>
      <title>GPU profiling for WebGPU workloads on Windows with Chrome</title>
      <link>/posts/profiling_webgpu/</link>
      <pubDate>Sun, 09 Jun 2024 11:55:28 +0200</pubDate>
      
      <guid>/posts/profiling_webgpu/</guid>
      <description>Fast Forward If you&amp;rsquo;ve read the article already and/or want to jump straight to profiling, go to the TL;DR section.
Context WebGPU is not a native graphics API, as in no hardware vendor provides specific drivers for their GPUs targeting this API. Instead, WebGPU runtimes like web browsers must implement backends for WebGPU using modern native APIs such as DirectX12, Vulkan or Metal. Those APIs are widely used, in particular for video games, and hardware vendors have developed great profiling tools for them.</description>
    </item>
    
    <item>
      <title>Exploring ways to optimize compute shaders - Part 1.</title>
      <link>/posts/compute_shaders/</link>
      <pubDate>Sat, 26 Sep 2020 15:16:15 +0200</pubDate>
      
      <guid>/posts/compute_shaders/</guid>
      <description>In this post we&amp;rsquo;ll be looking at compute shaders, profiling tools and failed experiments to improve performance. This is my journey learning compute shaders first through WebGPU and then Vulkan. My goal was to implement Conway&amp;rsquo;s Game Of Life algorithm in a brute force manner and to make it run as fast as possible on the GPU .
This will not be a tutorial on how to setup compute shaders.</description>
    </item>
    
    <item>
      <title>Integrating Dear ImGui in a custom Vulkan renderer</title>
      <link>/posts/vulkan_imgui/</link>
      <pubDate>Sat, 17 Aug 2019 15:16:15 +0200</pubDate>
      
      <guid>/posts/vulkan_imgui/</guid>
      <description>In this post we&amp;rsquo;ll be looking at integrating Dear ImGui in a custom Vulkan renderer. The audience I&amp;rsquo;m targeting is beginners still struggling with Vulkan. You should however have a basic Vulkan renderer already up and running. I followed Alexander Overvoorde&amp;rsquo;s amazing tutorial myself and I will use it as an example. The code is entirely available at vulkan-tutorial (go to the bottom of the page) if you&amp;rsquo;re willing to start from there as well.</description>
    </item>
    
    <item>
      <title>Ray Tracing In One Weekend</title>
      <link>/projects/raytracinginaweekend/</link>
      <pubDate>Mon, 13 Aug 2018 20:00:01 +0200</pubDate>
      
      <guid>/projects/raytracinginaweekend/</guid>
      <description>This is my own implementation of Ray Tracing in a weekend by Peter Shirley. It&amp;rsquo;s pretty simple and follows the book closely. The the two main modifications I made were using stb_image.h to output .png files and reorganizing the data a little so that the computation could be parallelized using OpenMP. The performance gain was great compared to the small amount of work it required.
If you&amp;rsquo;re not familiar with the book it involves creating a simple ray tracer from scratch.</description>
    </item>
    
    <item>
      <title>VirtuaLightJS</title>
      <link>/projects/virtualightjs/</link>
      <pubDate>Sun, 13 Aug 2017 20:00:01 +0200</pubDate>
      
      <guid>/projects/virtualightjs/</guid>
      <description>In 2017 I started studying computer graphics at school. We were given a lot of boiler plate code during practical exercises. Sometimes it felt like everything was working through some kind of dark magic. It was especially frustrating when something wouldn&amp;rsquo;t work. There were too many unknowns.
So during the summer holiday I gave myself the goal to write my own prototype from scratch. I decided to use WebGL because I knew a little JavaScript and figured it had the fastest iteration cycle.</description>
    </item>
    
    <item>
      <title>Posts</title>
      <link>/archive/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/archive/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Projects</title>
      <link>/projects/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/projects/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>