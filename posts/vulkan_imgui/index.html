<!DOCTYPE html>
<html lang="en">
  <head>
    
      <title>Integrating Dear ImGui in a custom Vulkan renderer :: Bits &amp; Pixies — My humble blog</title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content="In this post we&amp;rsquo;ll be looking at integrating Dear ImGui in a custom Vulkan renderer. The audience I&amp;rsquo;m targeting is beginners still struggling with Vulkan. You should however have a basic Vulkan renderer already up and running. I followed Alexander Overvoorde&amp;rsquo;s amazing tutorial myself and I will use it as an example. The code is entirely available at vulkan-tutorial (go to the bottom of the page) if you&amp;rsquo;re willing to start from there as well."/>
<meta name="keywords" content=""/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="/posts/vulkan_imgui/" />





<link rel="stylesheet" href="/assets/style.css">


<link rel="stylesheet" href="/style.css">


<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/img/apple-touch-icon-144-precomposed.png">
<link rel="shortcut icon" href="/img/favicon.png">


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Integrating Dear ImGui in a custom Vulkan renderer"/>
<meta name="twitter:description" content="In this post we&rsquo;ll be looking at integrating Dear ImGui in a custom Vulkan renderer. The audience I&rsquo;m targeting is beginners still struggling with Vulkan. You should however have a basic Vulkan renderer already up and running. I followed Alexander Overvoorde&rsquo;s amazing tutorial myself and I will use it as an example. The code is entirely available at vulkan-tutorial (go to the bottom of the page) if you&rsquo;re willing to start from there as well."/>



<meta property="og:title" content="Integrating Dear ImGui in a custom Vulkan renderer" />
<meta property="og:description" content="In this post we&rsquo;ll be looking at integrating Dear ImGui in a custom Vulkan renderer. The audience I&rsquo;m targeting is beginners still struggling with Vulkan. You should however have a basic Vulkan renderer already up and running. I followed Alexander Overvoorde&rsquo;s amazing tutorial myself and I will use it as an example. The code is entirely available at vulkan-tutorial (go to the bottom of the page) if you&rsquo;re willing to start from there as well." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/vulkan_imgui/" />
<meta property="article:published_time" content="2019-08-17T15:16:15+02:00" />
<meta property="article:modified_time" content="2019-08-17T15:16:15+02:00" /><meta property="og:site_name" content="Bits &amp; Pixies" />






  </head>
  <body class="dark-theme">
    <div class="container">
      <header class="header">
  <span class="header__inner">
    <a href="/" class="logo" style="text-decoration: none;">
  
    <span class="logo__mark"><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44">
  <path fill="none" d="M15 8l14.729 14.382L15 35.367"/>
</svg>
</span>
    <span class="logo__text">Bits &amp; Pixies</span>
    <span class="logo__cursor"></span>
  
</a>

    <span class="header__right" style="margin-left: 0.5rem;">
      <a href="https://twitter.com/frguthmann" target="_blank" class="socials" style="margin-right: 0.5rem;" ><svg class="theme-toggler" width="24" height="24" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"/></svg>
</a>
      <a href="https://github.com/frguthmann" target="_blank" class="socials" style="margin-right: 0.5rem;" ><svg class="theme-toggler" width="24" height="24" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path fill="currentColor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
</a>
      <a href="https://www.linkedin.com/in/frguthmann/" target="_blank" class="socials" style="margin-right: 0.5rem;" ><svg class="theme-toggler" width="24" height="24" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M100.28 448H7.4V148.9h92.88zM53.79 108.1C24.09 108.1 0 83.5 0 53.8a53.79 53.79 0 0 1 107.58 0c0 29.7-24.1 54.3-53.79 54.3zM447.9 448h-92.68V302.4c0-34.7-.7-79.2-48.29-79.2-48.29 0-55.69 37.7-55.69 76.7V448h-92.78V148.9h89.08v40.8h1.3c12.4-23.5 42.69-48.3 87.88-48.3 94 0 111.28 61.9 111.28 142.3V448z"/></svg>
</a>
    </span>
    <span class="header__right">
      
        <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/archive">Posts</a></li>
        
      
        
          <li><a href="/projects">Projects</a></li>
        
      
      
    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/archive">Posts</a></li>
      
    
      
        <li><a href="/projects">Projects</a></li>
      
    
  </ul>
</nav>

        <span class="menu-trigger">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M0 0h24v24H0z" fill="none"/>
            <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
          </svg>
        </span>
      
      <span class="theme-toggle">
        <svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>

      </span>
    </span>
  </span>
</header>


      <div class="content">
        
  <div class="post">
    <h2 class="post-title"><a href="/posts/vulkan_imgui/">Integrating Dear ImGui in a custom Vulkan renderer</a></h2>
    <div class="post-meta">
      
        <span class="post-date">
            17-08-2019
        </span>
      
      <span class="post-author">— Written by François Guthmann</span>
      
        <span class="post-read-time">— 29 min read</span>
      
    </div>

    

    

    <div class="post-content">
      

<p>In this post we&rsquo;ll be looking at integrating Dear ImGui in a custom Vulkan renderer. The audience I&rsquo;m targeting is beginners still struggling with Vulkan. You should however have a basic Vulkan renderer already up and running. I followed <a href="https://twitter.com/Overv" target="_blank" rel="noopener noreferrer">Alexander Overvoorde</a>&rsquo;s amazing tutorial myself and I will use it as an example. The code is entirely available at <a href="https://vulkan-tutorial.com/Multisampling" target="_blank" rel="noopener noreferrer">vulkan-tutorial</a> (go to the bottom of the page) if you&rsquo;re willing to start from there as well. The first chapters explain very carefully how to install the Vulkan SDK and deal with dependencies.</p>

<h2 id="first-contact">First contact</h2>

<p>Ready for a deep dive into Dear ImGui? Good! First, let&rsquo;s go to the <a href="https://github.com/ocornut/imgui/" target="_blank" rel="noopener noreferrer">official repository</a>. In the readme, there is a bunch of information about the reasons why the library was created and what tasks it is suited for. You should already know about the latter if you&rsquo;re interested in this library but the next lines are getting interesting:</p>

<blockquote>
<p>Dear ImGui is self-contained within a few files that you can easily copy and compile into your application/engine:<br />
- <code>imgui.cpp</code><br />
- <code>imgui.h</code><br />
- <code>imgui_demo.cpp</code><br />
- <code>imgui_draw.cpp</code><br />
- <code>imgui_widgets.cpp</code><br />
- <code>imgui_internal.h</code><br />
- <code>imconfig.h</code> (empty by default, user-editable)<br />
- <code>imstb_rectpack.h</code><br />
- <code>imstb_textedit.h</code><br />
- <code>imstb_truetype.h</code><br />
No specific build process is required. You can add the .cpp files to your project or <code>#include</code> them from an existing file.</p>
</blockquote>

<p>
  <img src="/images/vulkan_imgui/source_files.png"  alt="source files"  class="right"  style="float: right; border-radius: 8px;"  />


What&rsquo;s important to note here? All the .cpp files must be added to the project. It seems to be a common mistake to forget some of those because I made it myself and immediately found a Stack Overflow post about it. I was convinced this was a header only library, turns out it&rsquo;s not. So if you&rsquo;re using Visual Studio you should add all the .cpp files listed above to your source files.</p>

<p>You will also need to include the header files. To do so, you can either include them using <code>#include &quot;my_path/my_file.h&quot;</code> or tell VisualStudio where they are and include them using <code>#include &lt;my_file.h&gt;</code>. The menu that allows you to do this is located at: <code>Debug-&gt;Properties-&gt;C/C++-&gt;Additional Include Directories</code></p>

<p>Alright, let&rsquo;s keep on reading. Next is a code sample that looks pretty easy to understand.</p>

<pre><code class="language-c++">ImGui::Text(&quot;Hello, world %d&quot;, 123);  
if (ImGui::Button(&quot;Save&quot;))  
{  
    // do stuff  
}  
ImGui::InputText(&quot;string&quot;, buf, IM_ARRAYSIZE(buf));  
ImGui::SliderFloat(&quot;float&quot;, &amp;f, 0.0f, 1.0f);
</code></pre>

<p>So what then? Do I just include imgui.h, copy &amp; paste this code sample and it all works through some kind of dark magic? That would be really cool but also not very flexible. To understand why this cannot work we need to understand what Dear ImGui is. First of all it&rsquo;s an immediate mode GUI, which means the user is in control of the data not the GUI itself. This makes the GUI a little lower level than retained mode GUIs. However, as the author states, it&rsquo;s important to separate immediate mode GUI from immediate mode rendering.</p>

<blockquote>
<p>Immediate mode rendering (&hellip;) usually implies hammering your driver/GPU with a bunch of inefficient draw calls and state changes as the GUI functions are called. This is NOT what Dear ImGui does. Dear ImGui outputs vertex buffers and a small list of draw calls batches</p>
</blockquote>

<p>This sentence is also interesting for another reason. It just gave us the core idea of what we need to do to be able to use Dear ImGui. We need to be able to use the vertex buffers it outputs and process the draw call batches. It definitely explains why we cannot simply copy and paste some code samples. We need to integrate Dear ImGui deeper in our engine to be able to handle its outputs. How do we do that? Well, the next section of the readme is all about it.</p>

<blockquote>
<p>Integrating Dear ImGui within your custom engine is a matter of 1) wiring mouse/keyboard/gamepad inputs 2) uploading one texture to your GPU/render engine 3) providing a render function that can bind textures and render textured triangles. The examples/ folder is populated with applications doing just that.</p>
</blockquote>

<p>Ok so everything we need to know should be in the example folder, good. You know where to go next. But before we do that, the author leaves us with a little taunt.</p>

<blockquote>
<p>If you are an experienced programmer at ease with those concepts, it should take you about an hour to integrate Dear ImGui in your custom engine.</p>
</blockquote>

<p><strong>SPOILER</strong>: It took me more than an hour but I&rsquo;m not an experienced programmer nor am I an expert at Vulkan and that&rsquo;s ok! We&rsquo;ll get through this at our own pace.</p>

<h2 id="reading-more-than-the-readme">Reading more than the readme</h2>

<p>Let&rsquo;s open the example folder and see what we have. There are tons of things in there but only two folders about Vulkan: <code>example_glfw_vulkan</code> and <code>example_sdl_vulkan</code>. I don&rsquo;t have any experience with SDL and the tutorial I followed used GLFW so we&rsquo;re going to use <code>example_glfw_vulkan</code> for the rest of this post.</p>

<p>In this folder there are several build related files, Visual Studio files, shader code files and finally <code>main.cpp</code>. At the beginning of this file you will find some relevant information on how to setup Dear ImGui.</p>

<pre><code class="language-c++">// dear imgui: standalone example application for Glfw + Vulkan
// If you are new to dear imgui, see examples/README.txt and documentation at the top of imgui.cpp.
</code></pre>

<p>Let&rsquo;s start with <code>examples/README.txt</code>. It begins by reminding you that you will need to load the fonts to the GPU, pass the keyboard and mouse inputs to Dear ImGui, and provide it with a way to render triangles. Nothing new so far. The next bit holds more relevant information.</p>

<blockquote>
<p>This folder contains two things:</p>

<ul>
<li>Example bindings for popular platforms/graphics API, which you can use as is or adapt for your own use.<br />
They are the <code>imgui_impl_XXXX</code> files found in the <code>examples/</code> folder.<br /></li>
<li>Example applications (standalone, ready-to-build) using the aforementioned bindings.<br />
They are the in the <code>XXXX_example/</code> sub-folders.</li>
</ul>
</blockquote>

<p>So basically this means that in the <code>examples</code> folder there are some actual example applications but also some kind of extensions to the core files. Those extensions can be used to integrate Dear ImGui in your engine more easily. We should be interested in the <code>imgui_impl_vulkan</code> files which are located in the examples folder. Reading a bit more, it looks like we&rsquo;re going to need the <code>imgui_impl_glfw</code> files as well.</p>

<blockquote>
<p>Most the example bindings are split in 2 parts:</p>

<ul>
<li>The &ldquo;Platform&rdquo; bindings, in charge of: mouse/keyboard/gamepad inputs, cursor shape, timing, windowing.<br />
Examples: Windows (<code>imgui_impl_win32.cpp</code>), GLFW (<code>imgui_impl_glfw.cpp</code>), SDL2 (<code>imgui_impl_sdl.cpp</code>)<br /></li>
<li>The &ldquo;Renderer&rdquo; bindings, in charge of: creating the main font texture, rendering imgui draw data.<br />
Examples: DirectX11 (<code>imgui_impl_dx11.cpp</code>), GL3 (<code>imgui_impl_opengl3.cpp</code>), Vulkan (<code>imgui_impl_vulkan.cpp</code>)<br /></li>
</ul>
</blockquote>

<p>Ok so now some of you might be thinking that they want to code everything themselves and that using the <code>imgui_impl_vulkan</code> files is cheating or whatever. Yes, sure. You can rewrite everything from scratch yourself. It&rsquo;s probably the best approach in the end if you want to have control over your entire code base and make it all nice and uniform but as a first step, taking the easy way is probably for the best.</p>

<blockquote>
<p>If you use your own engine, you may decide to use some of existing bindings and/or rewrite some using your own API. As a recommendation, if you are new to Dear ImGui, try using the existing binding as-is first, before moving on to rewrite some of the code. Although it is tempting to rewrite both of the <code>imgui_impl_xxxx</code> files to fit under your coding style, consider that it is not necessary! In fact, if you are new to Dear ImGui, rewriting them will almost always be harder.</p>
</blockquote>

<p>And I think that&rsquo;s it for <code>examples/README.txt</code>. On to the next file, <code>imgui.cpp</code>. That one has a massive amount of information. In fact, the whole documentation of Dear ImGui is in there. I&rsquo;m not going to take you through it step by step because there is too much to cover. It is especially interesting if you want to re-write the <code>imgui_impl_xxxx</code> files but we&rsquo;re not doing that right now.</p>

<p>Ok back to where we came from, the <code>main.cpp</code> file from the <code>example_glfw_vulkan</code> folder. Now that we&rsquo;ve briefly read the documentation we&rsquo;re ready to understand what comes next.</p>

<pre><code class="language-c++">// Important note to the reader who wish to integrate imgui_impl_vulkan.cpp/.h in their own engine/app.
// - Common ImGui_ImplVulkan_XXX functions and structures are used to interface with imgui_impl_vulkan.cpp/.h.
//   You will use those if you want to use this rendering back-end in your engine/app.
// - Helper ImGui_ImplVulkanH_XXX functions and structures are only used by this example (main.cpp) and by 
//   the back-end itself (imgui_impl_vulkan.cpp), but should PROBABLY NOT be used by your own engine/app code.
// Read comments in imgui_impl_vulkan.h.
</code></pre>

<p>This is a very important piece of information. We&rsquo;re being told that we should be mainly using the <code>ImGui_ImplVulkan_XXX</code> functions and structures and not the <code>ImGui_ImplVulkanH_XXX</code> ones. Why? Because those are Vulkan related helper functions and you should already have most of those in your engine.</p>

<p>Now that we know what we can salvage and what we must plug into our own custom engine, we&rsquo;re ready to read the code itself.</p>

<h2 id="studying-the-code">Studying the code</h2>

<p>At the beginning of the <code>main.cpp</code> file we see that we&rsquo;ll obviously need to include <code>imgui.h</code>, <code>imgui_impl_glfw.h</code> and <code>imgui_impl_vulkan.h</code>. You can also see includes related to <code>GLFW</code> but you should already have those.</p>

<p>After that, there are a bunch of Vulkan related variables and functions declared. Those are the ones you should already have. Don&rsquo;t worry too much about them for now, we&rsquo;ll see later what your engine needs to expose to interface with Dear ImGui. For that, we&rsquo;ll look directly at the <code>main</code> function.</p>

<h3 id="initializing-dear-imgui">Initializing Dear ImGui</h3>

<p><a name="GLFW_Window"></a>The first block of code is about setting up a GLFW window, a Vulkan context, a surface and the main framebuffers. For this, some of the functions we skipped earlier are called. If you already have an up and running Vulkan application you have done this somewhere. Later on, we will need to expose some of the objects created in this phase like the GLFW <code>window</code> to interface Dear ImGui with your engine.</p>

<p>The next block is finally about some Dear ImGui specifics. Here we are creating a context for Dear ImGui, choosing the inputs we want to give it access to and a theme. These are functions from <code>imgui.h</code> only, there&rsquo;s nothing Vulkan or GLFW related here.</p>

<pre><code class="language-c++">// Setup Dear ImGui context
IMGUI_CHECKVERSION();
ImGui::CreateContext();
ImGuiIO&amp; io = ImGui::GetIO(); (void)io;
//io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;     // Enable Keyboard Controls
//io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad;      // Enable Gamepad Controls

// Setup Dear ImGui style
ImGui::StyleColorsDark();
//ImGui::StyleColorsClassic();
</code></pre>

<p>Then comes the tricky part, exposing the relevant parts of your engine to Dear ImGui. This is mainly done through an interface called <code>ImGui_ImplVulkan_InitInfo</code>.</p>

<pre><code class="language-c++">// Setup Platform/Renderer bindings
ImGui_ImplGlfw_InitForVulkan(window, true);
ImGui_ImplVulkan_InitInfo init_info = {};
init_info.Instance = g_Instance;
init_info.PhysicalDevice = g_PhysicalDevice;
init_info.Device = g_Device;
init_info.QueueFamily = g_QueueFamily;
init_info.Queue = g_Queue;
init_info.PipelineCache = g_PipelineCache;
init_info.DescriptorPool = g_DescriptorPool;
init_info.Allocator = g_Allocator;
init_info.MinImageCount = g_MinImageCount;
init_info.ImageCount = wd-&gt;ImageCount;
init_info.CheckVkResultFn = check_vk_result;
ImGui_ImplVulkan_Init(&amp;init_info, wd-&gt;RenderPass);
</code></pre>

<p>The first function <code>ImGui_ImplGlfw_InitForVulkan</code> comes from <code>imgui_impl_glfw.cpp</code>. It lets Dear ImGui interact with GLFW in a non intrusive way. For example, Dear ImGui will have access to the keyboard and mouse events but will still run the user registered callbacks afterwards. This way we don&rsquo;t have to care about handling GUI related inputs and we can still use the mouse position for things like camera control. To let the library help you with that, you will need to provide it with the <code>GLFW window</code> mentioned <a href="#GLFW_Window">earlier</a>.</p>

<p>Next up is the <code>ImGui_ImplVulkan_InitInfo</code> structure used by the <code>ImGui_ImplVulkan_Init</code> function. As you can see, they both follow the pattern <code>ImGui_ImplVulkan_XXX</code> and not <code>ImGui_ImplVulkanH_XXX</code>. This means we are encouraged to use them. We can already see that this structure is a big bridge between your engine and Dear ImGui. A lot of Vulkan internals are exposed here and we&rsquo;re going to figure out where they are in our engine.</p>

<h4 id="vulkan-instance-and-devices">Vulkan instance and devices</h4>

<p>The first variable is <code>g_Instance</code>, this is the <code>VkInstance</code> you had to create through the <code>vkCreateInstance</code> call. It&rsquo;s one of the lower level bricks of Vulkan. It holds the extensions required to run your program and the validation layers as well.</p>

<p>Then comes <code>g_PhysicalDevice</code> and <code>g_Device</code>. Those should be pretty self explanatory, they are the <code>VkPhysicalDevice</code> and <code>VkDevice</code> you created in your engine.</p>

<h4 id="queue">Queue</h4>

<p>The next bit can be a bit confusing. The structure needs a <code>QueueFamily</code> and a <code>Queue</code>. If you&rsquo;re familiar with Vulkan, you know that most operations are done through command buffers that are submitted to a queue. A queue comes from a queue family that allows a limited subset of operations. For example, a family could only allow compute operations or transfer operations. You might be using several queues yourself, so which one is the right one? The most likely one is the graphics queue as Dear ImGui will only be drawing stuff. If you quickly look through the code you&rsquo;ll find confirmation that we&rsquo;re indeed looking for a graphics queue and the related family.</p>

<pre><code class="language-c++">for (uint32_t i = 0; i &lt; count; i++){
    if (queues[i].queueFlags &amp; VK_QUEUE_GRAPHICS_BIT)
    {
        g_QueueFamily = i;
        break;
    }
}
</code></pre>

<p><strong>Note:</strong> I couldn&rsquo;t find any use for the graphics family in Dear ImGui&rsquo;s code so I tried putting a random number in there and it worked fine.</p>

<h4 id="pipeline-cache">Pipeline cache</h4>

<p>After the queue comes the <code>PipelineCache</code>. I haven&rsquo;t used those but I suppose this is an object that holds previously created pipelines such as a graphics pipeline. If you have one, good for you. If you don&rsquo;t, <code>VK_NULL_HANDLE</code> will work just fine. As far as I can tell, it&rsquo;s only used when creating Dear ImGui&rsquo;s graphics pipeline.</p>

<h4 id="descriptor-pool">Descriptor pool</h4>

<p>The <code>DescriptorPool</code> is another interesting element. Again, you probably already have one. If you&rsquo;re using image samplers or uniform buffers you have allocated their descriptors from a pool. However, looking at the code you can see that <code>g_DescriptorPool</code> is created using the following pool_sizes.</p>

<pre><code class="language-c++">VkDescriptorPoolSize pool_sizes[] =
{
    { VK_DESCRIPTOR_TYPE_SAMPLER, 1000 },
    { VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, 1000 },
    { VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, 1000 },
    { VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, 1000 },
    { VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER, 1000 },
    { VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, 1000 },
    { VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, 1000 },
    { VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, 1000 },
    { VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, 1000 },
    { VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, 1000 },
    { VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, 1000 }
};
</code></pre>

<p>There are A LOT of things in there. Your pool most likely doesn&rsquo;t have all this. Now there are two solutions, you can either extend your own pool to give it such capacity, or you can create a special one for Dear ImGui. I&rsquo;m not sure what the implications of having separated pools are but in order to keep everything well separated I decided to create a custom pool for Dear ImGui using the code provided at the end of the function <code>SetupVulkan</code> in <code>main.cpp</code>.</p>

<h4 id="memory-allocator">Memory allocator</h4>

<p>The <code>Allocator</code> field can be used to pass a specific memory allocator to the Vulkan functions called by Dear ImGui. You can pass <code>nullptr</code> if you don&rsquo;t have any.</p>

<h4 id="image-count">Image count</h4>

<p><code>MinImageCount</code> and <code>ImageCount</code> are related to the swapchain images. These are not Dear ImGui specific properties and your engine should expose them. <code>ImageCount</code> lets Dear ImGui know how many framebuffers and resources in general it should allocate. <code>MinImageCount</code> is not actually used even though there is a check at init time that its value is greater than 1.</p>

<h4 id="error-handling">Error handling</h4>

<p><code>CheckVkResultFn</code> is a function that is called to verify that some Vulkan operations went well. For example, all the <code>vkCreate</code> or <code>vkAllocate</code> functions will return a status code which should be <code>VK_SUCCESS</code>. If not, something went wrong. It&rsquo;s good practice to check and Dear ImGui allows you to pass your own error handling logic.</p>

<h4 id="final-call">Final call</h4>

<p>And finally we&rsquo;re initializing our <code>VulkanImpl</code> by calling <code>ImGui_ImplVulkan_Init</code> on the structure we just filled and a render pass. As you can expect, this should be a specific render pass dedicated to Dear ImGui. So where did that <code>wd-&gt;RenderPass</code> come from? Well earlier we skipped a few functions used to initialize Vulkan and it turns out they create this render pass as well. We&rsquo;ll have to create our own.</p>

<h4 id="render-pass">Render pass</h4>

<p>To create this render pass we first need to create a <code>VkAttachmentDescription</code>. Let&rsquo;s get rid of the boring fields first: we don&rsquo;t need any stencil so we don&rsquo;t care about its operators and the number of samples should probably be 1. Dear ImGui&rsquo;s output looks fine without MSAA. The format used depends on your swapchain and you should be able to find the relevant <code>VkFormat</code> somewhere in your code. It is usually extracted from the <code>SwapChainSupportDetails</code> structure returned by the function <code>querySwapChainSupport</code>.</p>

<p><a name="IMGUI_RENDER_PASS_INITIAL_LAYOUT"></a> Ok, so two of the most relevant parts here are <code>loadOp</code> and <code>initialLayout</code>. The first one should be <code>VK_ATTACHMENT_LOAD_OP_LOAD</code> because you want your GUI to be drawn over your main rendering. This tells Vulkan you don&rsquo;t want to clear the content of the framebuffer but you want to draw over it instead. Since we&rsquo;re going to draw some stuff, we also want <code>initialLayout</code> to be set to <code>VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</code> for optimal performance. And because this render pass is the last one, we want <code>finalLayout</code> to be set to <code>VK_IMAGE_LAYOUT_PRESENT_SRC_KHR</code>. This will automatically transition our attachment to the right layout for presentation.</p>

<pre><code class="language-c++">VkAttachmentDescription attachment = {};
attachment.format = swapChain.imagesFormat;
attachment.samples = VK_SAMPLE_COUNT_1_BIT;
attachment.loadOp = VK_ATTACHMENT_LOAD_OP_LOAD;
attachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE;
attachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
attachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
attachment.initialLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
attachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;
</code></pre>

<p>Now that we have this <code>VkAttachmentDescription</code> we can create the actual color <code>VkAttachmentReference</code> that our render pass needs. As we described <a href="#IMGUI_RENDER_PASS_INITIAL_LAYOUT">above</a>, the layout we&rsquo;re using to draw is <code>VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</code>.</p>

<pre><code class="language-c++">VkAttachmentReference color_attachment = {};
color_attachment.attachment = 0;
color_attachment.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
</code></pre>

<p>We can now create a subpass for our render pass using the previously created attachment. It is obviously a graphics subpass.</p>

<pre><code class="language-c++">VkSubpassDescription subpass = {};
subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
subpass.colorAttachmentCount = 1;
subpass.pColorAttachments = &amp;color_attachment;
</code></pre>

<p>Now here comes the tricky part. We have two render passes that we need to synchronize. As far as I can tell, there is no implicit synchronization in Vulkan regarding different render passes. There is a wide range of synchronization primitives to choose from in Vulkan but we can quickly eliminate some of them. Fences are used to synchronize the CPU and the GPU, this is way overkill. Semaphores are used to synchronize events across multiples queues and / or hardware. It is not relevant here either. I&rsquo;m not too familiar with events, it seems they could do the trick but we won&rsquo;t be using them here.</p>

<p>This leaves us with pipeline barriers and external subpass dependencies. As explained in this <a target="blank" href="http://themaister.net/blog/2019/08/14/yet-another-blog-explaining-vulkan-synchronization/">great overview of Vulkan synchronization</a>, they are both pretty similar. A subpass dependency is basically the driver inserting a pipeline barrier for you. I chose this method because it is theoretically more optimized than doing it by hand. Also, I looked at <code>imgui_impl_vulkan.cpp</code> and that&rsquo;s how it&rsquo;s done in there, ahum.</p>

<p>Ok so our <code>srcSubpass</code> must be <code>VK_SUBPASS_EXTERNAL</code> to create a dependency outside the current render pass. We can refer to our first and only subpass in <code>dstSubpass</code> by its index 0. Now we need to state what we&rsquo;re waiting for. Before drawing our GUI, we want our geometry to be already rendered. That means we want the pixels to be already written to the framebuffer. Fortunately, there is a stage called <code>VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</code> for that and we can set our <code>srcStageMask</code> to it. We can also set our <code>dstStageMask</code> to this same value because our GUI will also be drawn to the same target. We&rsquo;re basically waiting for pixels to be written before we can write pixels ourselves.</p>

<p>As for the access masks, I&rsquo;m not sure I understand exactly how they work. If we look at <code>imgui_impl_vulkan.cpp</code>, we can see that <code>srcAccessMask</code> is set to 0 and <code>dstAccessMask</code> is set to <code>VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT</code>. I would argue the <code>srcAccessMask</code> should use the <code>VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT</code> flag as well. We are waiting for writes to be done with before we can write ourselves. I don&rsquo;t have the answer here, do as you wish. Both work on my computer.</p>

<pre><code class="language-c++">VkSubpassDependency dependency = {};
dependency.srcSubpass = VK_SUBPASS_EXTERNAL;
dependency.dstSubpass = 0;
dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
dependency.srcAccessMask = 0;  // or VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;
dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;
</code></pre>

<p><a name="IMGUI_RENDER_PASS"></a>
We are now ready to finally create the renderpass by putting together everything we just created. For the sake of completeness, here is the code to finalize the creation of the render pass.</p>

<pre><code class="language-c++">VkRenderPassCreateInfo info = {};
info.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
info.attachmentCount = 1;
info.pAttachments = &amp;attachment;
info.subpassCount = 1;
info.pSubpasses = &amp;subpass;
info.dependencyCount = 1;
info.pDependencies = &amp;dependency;
if (vkCreateRenderPass(device, &amp;info, nullptr, &amp;imGuiRenderPass) != VK_SUCCESS) {
    throw std::runtime_error(&quot;Could not create Dear ImGui's render pass&quot;);
}
</code></pre>

<p>By the way, don&rsquo;t forget to change your penultimate render pass as well. Let&rsquo;s say you had only one pass that did the main rendering. You should set its <code>finalLayout</code> field to <code>VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</code> since it&rsquo;s not presenting anymore.</p>

<h4 id="uploading-fonts-to-the-gpu">Uploading fonts to the GPU</h4>

<p>The next bit as the comment suggests is about uploading fonts to the GPU. It might look complicated at first but it all boils down to a single line specific to Dear ImGui.
I haven&rsquo;t investigated what it does exactly but there are lots of comments around it pointing in the right direction if you are interested.</p>

<pre><code class="language-c++">ImGui_ImplVulkan_CreateFontsTexture(command_buffer);
</code></pre>

<p>The code around it handles the command buffer creation and submission. You might already have functions ready for one time usage command buffers (if you have followed <a href="https://vulkan-tutorial.com/Texture_mapping/Images" target="_blank" rel="noopener noreferrer">Alexander Overvoorde&rsquo;s tutorial</a> for example). The code simplifies to 3 lines.</p>

<pre><code class="language-c++">VkCommandBuffer command_buffer = beginSingleTimeCommands();
ImGui_ImplVulkan_CreateFontsTexture(command_buffer);
endSingleTimeCommands(command_buffer);      
</code></pre>

<p>If you don&rsquo;t have anything like that ready, it&rsquo;s ok. You can simply reuse the code provided as is. The variable <code>g_Device</code> is the logical device you created in your engine and <code>g_Queue</code> is the graphics queue you queried as well. You might be wondering what you should be using for the <code>VkCommandBuffer</code> and <code>VkCommandPool</code>. Well, we&rsquo;ll reuse the command buffers and command pools that allow us to submit the Dear ImGui related commands to the GPU. We&rsquo;ll be getting to those in a moment.</p>

<h3 id="the-main-loop">The main loop</h3>

<p>Ok so as far as we can tell, we&rsquo;re done with initialization. You can tell because the main loop is starting. We&rsquo;re starting an infinite loop that will only stop if GLFW tells us the user asked to close the window. Again, you should already have this up and running somewhere.</p>

<pre><code class="language-c++">while (!glfwWindowShouldClose(window)){
    // Your amazing Vulkan stuff
}       
</code></pre>

<p>The beginning of this function is pretty standard: a call to <code>glfwPollEvents</code> to detect user inputs and some code to recreate the swapchain if needed. You should already have both of those to handle user inputs and events such as the window being resized. The only thing here relevant to DearImGui is that upon recreating the swapchain, the minimum amount of image views might have changed. You have to tell Dear ImGui about it by calling <code>ImGui_ImplVulkan_SetMinImageCount</code>.</p>

<pre><code class="language-c++">if (g_SwapChainRebuild)
{
    g_SwapChainRebuild = false;
    ImGui_ImplVulkan_SetMinImageCount(g_MinImageCount);
    ImGui_ImplVulkanH_CreateWindow(g_Instance, g_PhysicalDevice, g_Device, &amp;g_MainWindowData, 
            g_QueueFamily, g_Allocator, g_SwapChainResizeWidth, g_SwapChainResizeHeight, g_MinImageCount);
    g_MainWindowData.FrameIndex = 0;
}
</code></pre>

<h4 id="describing-the-ui">Describing the UI</h4>

<p>The next part is where you can actually code your UI. This is not what this article is about so we&rsquo;ll just use the demo window. It also helps getting a higher view of what&rsquo;s going on.</p>

<pre><code class="language-c++">ImGui_ImplVulkan_NewFrame();
ImGui_ImplGlfw_NewFrame();
ImGui::NewFrame();
ImGui::ShowDemoWindow();
ImGui::Render();
</code></pre>

<p>First we need to create a new frame, then we describe our UI and finally we ask Dear ImGui to render it. It&rsquo;s pretty straight forward. You might be wondering why creating a new frame takes 3 different calls and that&rsquo;s a legitimately good question. The implementation of <code>ImGui_ImplVulkan_NewFrame</code> is actually empty. I suppose this is just a precaution from the author in case some day there is some Vulkan specific code to add in here. The call to <code>ImGui_ImplGlfw_NewFrame</code> on the other hand makes sense. It is used to handle the user inputs, the screen resize etc. Finally, we need to initialize an actual ImGuiFrame.</p>

<p>Now for the last three lines of our main loop. The first one is specific to the example and is irrelevant. The next two on the other hand are the ones I&rsquo;m interested in. You should actually have some version of those yourself. This is where you acquire an imageview from the swapchain, maybe record some command buffers and finally submit them. We will still need to modify those functions slightly to integrate our new rendering operations.</p>

<pre><code class="language-c++">memcpy(&amp;wd-&gt;ClearValue.color.float32[0], &amp;clear_color, 4 * sizeof(float));
FrameRender(wd);
FramePresent(wd);
</code></pre>

<h4 id="rendering-the-ui-part-1">Rendering the UI - Part 1</h4>

<p>Let&rsquo;s look at <code>FrameRender</code> first. The first few lines are about acquiring a new image from the swapchain and synchronizing the CPU with GPU using fences. This last operation ensures that we&rsquo;re not submitting more frames to the GPU than we have available. This is not specific to Dear ImGui, and you should have the same kind of construct in your code.</p>

<pre><code class="language-c++">VkSemaphore image_acquired_semaphore  = wd-&gt;FrameSemaphores[wd-&gt;SemaphoreIndex].ImageAcquiredSemaphore;
VkSemaphore render_complete_semaphore = wd-&gt;FrameSemaphores[wd-&gt;SemaphoreIndex].RenderCompleteSemaphore;
err = vkAcquireNextImageKHR(g_Device, wd-&gt;Swapchain, UINT64_MAX, image_acquired_semaphore, VK_NULL_HANDLE, &amp;wd-&gt;FrameIndex);
check_vk_result(err);

ImGui_ImplVulkanH_Frame* fd = &amp;wd-&gt;Frames[wd-&gt;FrameIndex];
{
    err = vkWaitForFences(g_Device, 1, &amp;fd-&gt;Fence, VK_TRUE, UINT64_MAX);    // wait indefinitely instead of periodically checking
    check_vk_result(err);

    err = vkResetFences(g_Device, 1, &amp;fd-&gt;Fence);
    check_vk_result(err);
}
</code></pre>

<p>The next part is getting more interesting. We&rsquo;re resetting a command pool and starting to record commands into a command buffer. So why would we be doing this? Well, our UI can have multiple states, windows will come and go, buttons will be added and so on. We cannot record our buffers once and for all. We need to record them every time the content changes. The quick and easy solution is to do this every frame. I suppose one could find a way to hash the UI and rebuild command buffers only when necessary but we won&rsquo;t be doing this right now.</p>

<pre><code class="language-c++">{
    err = vkResetCommandPool(g_Device, fd-&gt;CommandPool, 0);
    check_vk_result(err);
    VkCommandBufferBeginInfo info = {};
    info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
    info.flags |= VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;
    err = vkBeginCommandBuffer(fd-&gt;CommandBuffer, &amp;info);
    check_vk_result(err);
}
</code></pre>

<h4 id="more-initialization">More initialization</h4>

<p>We haven&rsquo;t really setup any command pools or command buffers in the initialization part so we&rsquo;ll have to remedy this. The first thing we need to know is how many of those we&rsquo;ll need. A quick look further down the code should tell you that a single command buffer will be enough to draw. Same goes for the command pool. However and as always in Vulkan, we might be preparing multiple frames in advance. That means we cannot use the same command buffer for multiple frames. We&rsquo;ll have to create as many command buffers and command pools as we have frames.</p>

<p>One could think a single pool would be enough to hold all the command buffers but <code>vkResetCommandPool</code> will reset all command buffers, including the ones that are still in use. For this reason, we need several of them. The good news is the validation layers will catch you (well, they caught me) red handed if you try.</p>

<pre><code class="language-c++">imGuiCommandPools.resize(imageViews.size());
imGuiCommandBuffers.resize(imageViews.size());
for (size_t i = 0; i &lt; imageViews.size(); i++) {
    createCommandPool(&amp;imGuiCommandPools[i], VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT);
    createCommandBuffers(&amp;imGuiCommandBuffers[i], 1, imGuiCommandPools[i]);
}
</code></pre>

<p>Let&rsquo;s look at the command pool first. Our <code>createCommandPool</code> function only takes two arguments, the command pool to create and the flags we want to set. In this case we&rsquo;re using <code>VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT</code>. Why do we use this flag? First because I looked at <code>imgui_impl_vulkan.cpp</code> and saw it was set there. And second because we&rsquo;re calling <code>vkResetCommandPool</code> every frame. Here is what the specification has to say about that.</p>

<blockquote>
<p>VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT allows any command buffer allocated from a pool to be individually reset to the initial state; either by calling vkResetCommandBuffer, or via the implicit reset when calling vkBeginCommandBuffer.</p>
</blockquote>

<p>So the spec is basically saying that calling <code>vkResetCommandPool</code> is useless, right? Well, I would assume so. I tried it on my computer and it worked, no complain from the validation layers either. I guess it&rsquo;s up to you to decide how explicit you want your code to be. But this got me thinking, if I don&rsquo;t need to reset the entire pool, then I don&rsquo;t need to have multiple pools either. I tried setting all command buffers from the same pool and removing the call to <code>vkResetCommandPool</code> and everything seems fine, validation layer wise or other. Here is what the new code looks like.</p>

<pre><code class="language-c++">createCommandPool(&amp;imGuiCommandPool, VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT);
imGuiCommandBuffers.resize(imageViews.size());
createCommandBuffers(imGuiCommandBuffers.data(), static_cast&lt;uint32_t&gt;(imGuiCommandBuffers.size()), imGuiCommandPool;
</code></pre>

<p>On the other hand, not setting the <code>VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT</code> flag at all will get you in a lot of trouble!</p>

<blockquote>
<p>Validation layer returned an error:<br />
Call to vkBeginCommandBuffer() on command buffer (0x537ba90) attempts to implicitly reset cmdBuffer created from command pool (0x3c) that does NOT have the VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT bit set. The Vulkan spec states:<br />
If commandBuffer was allocated from a VkCommandPool which did not have the VK_COMMA
ND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT flag set, commandBuffer must be in the initial state. (<a href="https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VUID-vkBeginCommandBuffer-commandBuffer-00050">https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VUID-vkBeginCommandBuffer-commandBuffer-00050</a>)</p>
</blockquote>

<p>If you need it, here&rsquo;s the complete code of the <code>createCommandPool</code> function. There is nothing fancy about it.</p>

<pre><code class="language-c++">void createCommandPool(VkCommandPool* commandPool, VkCommandPoolCreateFlags flags) {
    VkCommandPoolCreateInfo commandPoolCreateInfo = {};
    commandPoolCreateInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
    commandPoolCreateInfo.queueFamilyIndex = graphicsFamilyIndex;
    commandPoolCreateInfo.flags = flags;

    if (vkCreateCommandPool(device, &amp;commandPoolCreateInfo, nullptr, commandPool) != VK_SUCCESS) {
        throw std::runtime_error(&quot;Could not create graphics command pool&quot;);
    }
}
</code></pre>

<p>Finally we can create our command buffer. There is nothing specific about this, we just pass the associated command pool and allocate the command buffer. Note that <code>vkAllocateCommandBuffers</code> can allocate several buffers at the same time but only from the same pool. This is why we had to call <code>createCommandBuffers</code> inside the loop in the first version and we can now call it a single time to allocate all command buffers at once. Again, here is the full code if you need it.</p>

<pre><code class="language-c++">void createCommandBuffers(VkCommandBuffer* commandBuffer, uint32_t commandBufferCount, VkCommandPool &amp;commandPool) {
    VkCommandBufferAllocateInfo commandBufferAllocateInfo = {};
    commandBufferAllocateInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
    commandBufferAllocateInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
    commandBufferAllocateInfo.commandPool = commandPool;
    commandBufferAllocateInfo.commandBufferCount = commandBufferCount;
    vkAllocateCommandBuffers(device, &amp;commandBufferAllocateInfo, commandBuffer);
}
</code></pre>

<p>Now is a good time to go back to the font uploading code if you chose to keep the code provided by <code>main.cpp</code>. You can use our new command pool and any of the new command buffers to upload the fonts to the GPU.</p>

<h4 id="rendering-the-ui-part-2">Rendering the UI - Part 2</h4>

<p><a name="IMGUI_START_RENDER_PASS"></a>
Back to our <code>FrameRender</code> function. The next bit is about starting a render pass. We can see that we&rsquo;ll need a render pass. This is the one we specifically created for DearImGui <a href="#IMGUI_RENDER_PASS">here</a>. We also see that we&rsquo;ll need a framebuffer. The thing is we haven&rsquo;t created any so we&rsquo;ll need to do some more initialization.</p>

<p>The width and height parameters can be found in the <code>VkExtent2D</code> you used to create your swapchain and the <code>clearValueCount</code> and <code>pClearValues</code> define what color you want to use to clear the framebuffer. Finally, we start the renderpass using the current frame&rsquo;s command buffer and the info we just built.</p>

<pre><code class="language-c++">{
    VkRenderPassBeginInfo info = {};
    info.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
    info.renderPass = wd-&gt;RenderPass;
    info.framebuffer = fd-&gt;Framebuffer;
    info.renderArea.extent.width = wd-&gt;Width;
    info.renderArea.extent.height = wd-&gt;Height;
    info.clearValueCount = 1;
    info.pClearValues = &amp;wd-&gt;ClearValue;
    vkCmdBeginRenderPass(fd-&gt;CommandBuffer, &amp;info, VK_SUBPASS_CONTENTS_INLINE);
}
</code></pre>

<p>I haven&rsquo;t insisted very much on the fact that for each <code>imageView</code> from the swapchain we use specific resources. This should be very clear in your mind. This is why we have an array of command buffers and we&rsquo;ll soon be creating an array of framebuffers. The example provided by Dear ImGui kind of hides this complexity behind its <code>fd</code> object. In the above snippet, you should understand <code>fd-&gt;XXX</code> as <code>imageViewResources[imageViewId]-&gt;XXX</code>. The index <code>imageViewId</code> is provided by <code>vkAcquireNextImageKHR</code>.</p>

<h4 id="more-initialization-part-2">More initialization - Part 2</h4>

<p>So what should we use as our framebuffer? You probably already have an array of framebuffers lying around, one for each frame in flight. So why not use them? You can try but the validation layers are very likely to yell at you, again. They will first tell you that you&rsquo;re trying to present an image that is in the wrong layout, then that the renderpass is incompatible with the framebuffer because there is an incompatible number of attachments and so on. In short, it&rsquo;s a bad idea. They&rsquo;re not compatible. We have once again (and I promise, it&rsquo;s the last time) forgotten to initialize something.</p>

<p>So what is wrong with our main rendering framebuffers? Well first they might have too many attachments. Dear ImGui doesn&rsquo;t require a depth buffer for example or if you&rsquo;re using MSAA, Dear ImGui doesn&rsquo;t require a resolve buffer either. What do they need then? The easiest is to <code>ctrl-f</code> your way through <code>imgui_impl_vulkan.cpp</code> to find a call to <code>vkCreateFramebuffer</code>. Here is what I found.</p>

<pre><code class="language-c++">{
    VkImageView attachment[1];
    VkFramebufferCreateInfo info = {};
    info.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
    info.renderPass = wd-&gt;RenderPass;
    info.attachmentCount = 1;
    info.pAttachments = attachment;
    info.width = wd-&gt;Width;
    info.height = wd-&gt;Height;
    info.layers = 1;
    for (uint32_t i = 0; i &lt; wd-&gt;ImageCount; i++)
    {
        ImGui_ImplVulkanH_Frame* fd = &amp;wd-&gt;Frames[i];
        attachment[0] = fd-&gt;BackbufferView;
        err = vkCreateFramebuffer(device, &amp;info, allocator, &amp;fd-&gt;Framebuffer);
        check_vk_result(err);
    }
}
</code></pre>

<p>As I mentioned, we only need one attachment, the one we will draw to. The renderpass, width and height are exactly the same as the ones we provided <a href="#IMGUI_START_RENDER_PASS">here</a> and  <code>layers</code> is 1 because our imageViews are single images and not arrays.</p>

<p>Now for the actual framebuffer creation, we&rsquo;re again creating as many as we have imageViews. The naming in here is not very explicit to me but what&rsquo;s going on is actually pretty simple. We just need to create a framebuffer for each imageView and reference it in the attachment. That&rsquo;s all that is going on in the for loop. The imageView is <code>wd-&gt;Frames[i]-&gt;BackbufferView</code> in Dear ImGui&rsquo;s code. Again, you already have those somewhere otherwise you would not able to draw or present anything.</p>

<h4 id="rendering-the-ui-part-3">Rendering the UI - Part 3</h4>

<p>So, what did we do? We created our GUI specific framebuffers and we used them to begin a render pass inside the command buffer we&rsquo;re currently recording. The next function call is the one doing all the work. This is Dear ImGui adding all its draw calls to our render pass.</p>

<pre><code class="language-c++">// Record Imgui Draw Data and draw funcs into command buffer
ImGui_ImplVulkan_RenderDrawData(ImGui::GetDrawData(), fd-&gt;CommandBuffer);
</code></pre>

<p>After all the calls were recorded, we can end our render pass and our command buffer. In the current version of the example, the call to end the command buffer is a little further down the code but I find it more readable to put it right after we end our render pass. It doesn&rsquo;t change the behavior at all.</p>

<pre><code class="language-c++">// Submit command buffer
vkCmdEndRenderPass(fd-&gt;CommandBuffer);
err = vkEndCommandBuffer(fd-&gt;CommandBuffer);
check_vk_result(err);
</code></pre>

<p>The next part in the example is submitting the command buffer to the GPU. This code is a bit specific to your engine and depends on how you setup synchronization between frames. The good thing is you already have this code. You basically submit commands through a call to <code>vkQueueSubmit</code> with a <code>VkSubmitInfo</code> as an argument. This submit info structure has a field <code>pCommandBuffers</code> in which you put a single command buffer or an array of them. The only thing you have to do is to add the GUI related command buffer to this array. If you only had one command buffer before, just create an array with those two command buffers on the fly. From a top level, it should look something like this.</p>

<pre><code class="language-c++">std::array&lt;VkCommandBuffer, 2&gt; submitCommandBuffers = 
    { commandBuffers[imageIndex], imGuiCommandBuffers[imageIndex] };
VkSubmitInfo submitInfo = {};
submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
(...)
submitInfo.commandBufferCount = static_cast&lt;uint32_t&gt;(submitCommandBuffers.size());
submitInfo.pCommandBuffers = submitCommandBuffers.data();
if (vkQueueSubmit(graphicsQueue, 1, &amp;submitInfo, inFlightFences[currentFrame]) != VK_SUCCESS) {
    throw std::runtime_error(&quot;Could not submit commands to the graphics queue&quot;);
}
</code></pre>

<h4 id="presenting-the-frame">Presenting the frame</h4>

<p>And we&rsquo;re done with <code>FrameRender</code>! We&rsquo;re left with <code>FramePresent</code> and then we&rsquo;ll be done with the main loop. And you know what? There is nothing specific to Dear ImGui about it. That&rsquo;s right, you already have this code once again. So yeah, we&rsquo;re done. Go run that program and hope it works! Did it? Good! If not, do not hesitate to leave a comment and we&rsquo;ll see what we can do about it!</p>

<p>Also, do not forget to take a look at the console, the validation layers will complain that you didn&rsquo;t do the right thing and cleaned after yourself. We created many resources for Dear ImGui and never took time to clean those. Do not forget either that on swapchain recreation, the Dear ImGui renderpass, command pools, command buffers and framebuffers must be destroyed and then recreated!</p>

<pre><code class="language-c++">// Resources to destroy on swapchain recreation
for (auto framebuffer : imGuiFramebuffers) {
    vkDestroyFramebuffer(device, framebuffer, nullptr);
}

vkDestroyRenderPass(device, imGuiRenderPass, nullptr);

vkFreeCommandBuffers(device, imGuiCommandPool, static_cast&lt;uint32_t&gt;(imGuiCommandBuffers.size()), imGuiCommandBuffers.data());
vkDestroyCommandPool(device, imGuiCommandPool, nullptr);

// Resources to destroy when the program ends
ImGui_ImplVulkan_Shutdown();
ImGui_ImplGlfw_Shutdown();
ImGui::DestroyContext();
vkDestroyDescriptorPool(device, imguiDescriptorPool, nullptr);
</code></pre>

<h2 id="final-words">Final words</h2>

<p>Wow, we finally made it through all this. You should now be able to render some geometry and add some GUI over it. Now go make something cool with it and send it to me on Twitter <a href="https://www.twitter.com/frguthmann" target="_blank" rel="noopener noreferrer">@frguthmann</a>. You can also leave a comment below, Disqus has a guest mode. Thank you for reading and do not hesitate to tell me if something is wrong or unclear. Any feedback is welcome :).</p>

    </div>
    

    <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "bitsandpixies" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>

      </div>

      
        <footer class="footer">
  <div class="footer__inner">
    
      <a href="/" class="logo" style="text-decoration: none;">
  
    <span class="logo__mark"><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44">
  <path fill="none" d="M15 8l14.729 14.382L15 35.367"/>
</svg>
</span>
    <span class="logo__text">François Guthmann</span>
    <span class="logo__cursor"></span>
  
</a>

      <div class="copyright">
        <span>© 2019 Powered by <a href="https://gohugo.io" target="_blank" rel="noopener">Hugo</a></span>
        <span>Theme created by <a href="https://twitter.com/panr" target="_blank" rel="noopener">panr</a></span>
      </div>
    
  </div>
</footer>

<script src="/assets/main.js"></script>
<script src="/assets/prism.js"></script>


      
    </div>

    
  </body>
</html>
